// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: likes.sql

package dbs

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const likesByCommentIDs = `-- name: LikesByCommentIDs :many
SELECT likes.comment_id, likes.created_at, users.user_id, users.username
FROM likes
JOIN users ON likes.created_by = users.user_id
WHERE likes.comment_id = ANY($1::BIGINT[]) AND likes.active = TRUE
`

type LikesByCommentIDsRow struct {
	CommentID int64
	CreatedAt time.Time
	UserID    int64
	Username  string
}

func (q *Queries) LikesByCommentIDs(ctx context.Context, commentIds []int64) ([]LikesByCommentIDsRow, error) {
	rows, err := q.query(ctx, q.likesByCommentIDsStmt, likesByCommentIDs, pq.Array(commentIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LikesByCommentIDsRow
	for rows.Next() {
		var i LikesByCommentIDsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.CreatedAt,
			&i.UserID,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const likesUpsert = `-- name: LikesUpsert :exec
INSERT INTO likes (comment_id, active, created_at, created_by, updated_at, updated_by)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (comment_id, created_by) 
DO UPDATE SET 
    active = EXCLUDED.active, 
    updated_at = EXCLUDED.updated_at, 
    updated_by = EXCLUDED.updated_by
`

type LikesUpsertParams struct {
	CommentID int64
	Active    bool
	CreatedAt time.Time
	CreatedBy int64
	UpdatedAt time.Time
	UpdatedBy int64
}

func (q *Queries) LikesUpsert(ctx context.Context, arg LikesUpsertParams) error {
	_, err := q.exec(ctx, q.likesUpsertStmt, likesUpsert,
		arg.CommentID,
		arg.Active,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}
