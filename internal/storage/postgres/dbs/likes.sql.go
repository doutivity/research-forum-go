// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: likes.sql

package dbs

import (
	"context"
	"time"
)

const likesByCommentID = `-- name: LikesByCommentID :many
SELECT likes.comment_id, likes.active, likes.created_at, likes.created_by, likes.updated_at, likes.updated_by, users.user_id, users.username
FROM likes
JOIN users ON likes.created_by = users.user_id
WHERE likes.comment_id = $1 AND likes.active = TRUE
`

type LikesByCommentIDRow struct {
	CommentID int64
	Active    bool
	CreatedAt time.Time
	CreatedBy int64
	UpdatedAt time.Time
	UpdatedBy int64
	UserID    int64
	Username  string
}

func (q *Queries) LikesByCommentID(ctx context.Context, commentID int64) ([]LikesByCommentIDRow, error) {
	rows, err := q.query(ctx, q.likesByCommentIDStmt, likesByCommentID, commentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LikesByCommentIDRow
	for rows.Next() {
		var i LikesByCommentIDRow
		if err := rows.Scan(
			&i.CommentID,
			&i.Active,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.UserID,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const likesNew = `-- name: LikesNew :one
INSERT INTO likes (comment_id, active, created_at, created_by, updated_at, updated_by)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (comment_id, created_by) 
DO UPDATE SET 
    active = NOT likes.active, 
    updated_at = EXCLUDED.updated_at, 
    updated_by = EXCLUDED.updated_by
RETURNING comment_id, created_by
`

type LikesNewParams struct {
	CommentID int64
	Active    bool
	CreatedAt time.Time
	CreatedBy int64
	UpdatedAt time.Time
	UpdatedBy int64
}

type LikesNewRow struct {
	CommentID int64
	CreatedBy int64
}

func (q *Queries) LikesNew(ctx context.Context, arg LikesNewParams) (LikesNewRow, error) {
	row := q.queryRow(ctx, q.likesNewStmt, likesNew,
		arg.CommentID,
		arg.Active,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	var i LikesNewRow
	err := row.Scan(&i.CommentID, &i.CreatedBy)
	return i, err
}
